import React from 'react';
import { screen, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { renderWithProviders } from '../test-utils';
import AnimalsManagement from './AnimalsManagement';
import { animalService } from '../services/animals';
import { Animal } from '../types/api';

// Mock the animal service
jest.mock('../services/animals');

/* eslint-disable */
const mockAnimalService = animalService as jest.Mocked<typeof animalService>;

// Mock window.confirm
const originalConfirm = window.confirm;

describe('AnimalsManagement Component', () => {
  const mockUser = {
    id: 'user1',
    email: 'farmer@test.com',
    name: 'Test Farmer',
    farmId: 'farm1',
  };

  const mockAnimals: Animal[] = [
    {
      id: 'animal1',
      farm: 'farm1',
      tagNumber: 'TAG001',
      name: 'Bessie',
      species: 'cattle',
      gender: 'female',
      healthStatus: 'healthy',
      acquisitionInfo: {
        type: 'purchased',
        date: '2024-01-15',
      },
      healthRecords: [],
      productionRecords: [],
      feedingSchedule: [],
      createdAt: '2024-01-15T10:00:00Z',
      updatedAt: '2024-01-15T10:00:00Z',
      createdBy: 'user1',
    },
    {
      id: 'animal2',
      farm: 'farm1',
      tagNumber: 'TAG002',
      name: 'Wilbur',
      species: 'pig',
      gender: 'male',
      healthStatus: 'sick',
      acquisitionInfo: {
        type: 'born_on_farm',
        date: '2024-02-10',
      },
      healthRecords: [],
      productionRecords: [],
      feedingSchedule: [],
      createdAt: '2024-02-10T10:00:00Z',
      updatedAt: '2024-02-10T10:00:00Z',
      createdBy: 'user1',
    },
    {
      id: 'animal3',
      farm: 'farm1',
      tagNumber: 'TAG003',
      name: 'Dolly',
      species: 'sheep',
      gender: 'female',
      healthStatus: 'quarantine',
      acquisitionInfo: {
        type: 'inherited',
        date: '2024-03-20',
      },
      healthRecords: [],
      productionRecords: [],
      feedingSchedule: [],
      createdAt: '2024-03-20T10:00:00Z',
      updatedAt: '2024-03-20T10:00:00Z',
      createdBy: 'user1',
    },
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    window.confirm = jest.fn();
    mockAnimalService.getAnimals.mockResolvedValue({
      data: mockAnimals,
      pagination: {
        current: 1,
        pages: 1,
        total: 3,
      },
    });
  });

  afterEach(() => {
    window.confirm = originalConfirm;
  });

  describe.skip('Rendering', () => {
    it('should render the component with title and add button', async () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      expect(screen.getByText('Animal Management')).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /add animal/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /reload/i })).toBeInTheDocument();
    });

    it('should render table headers', async () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tag')).toBeInTheDocument();
      });

      expect(screen.getByText('Name')).toBeInTheDocument();
      expect(screen.getByText('Species')).toBeInTheDocument();
      expect(screen.getByText('Gender')).toBeInTheDocument();
      expect(screen.getByText('Health')).toBeInTheDocument();
      expect(screen.getByText('Created')).toBeInTheDocument();
      expect(screen.getByText('Actions')).toBeInTheDocument();
    });

    it('should display animals in the table', async () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      expect(screen.getByText('Bessie')).toBeInTheDocument();
      expect(screen.getByText('TAG002')).toBeInTheDocument();
      expect(screen.getByText('Wilbur')).toBeInTheDocument();
      expect(screen.getByText('TAG003')).toBeInTheDocument();
      expect(screen.getByText('Dolly')).toBeInTheDocument();
    });

    it.skip('should show alert when no farmId is available', () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: { ...mockUser, farmId: undefined }, isAuthenticated: true } },
      });

      expect(screen.getByText(/please select a farm to manage animals/i)).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /select farm/i })).toBeInTheDocument();
    });
  });

  describe.skip('Loading State', () => {
    it('should show loading message initially', () => {
      mockAnimalService.getAnimals.mockImplementation(() => new Promise(() => {})); // Never resolves

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      expect(screen.getByText('Loading animals…')).toBeInTheDocument();
    });

    it('should show animals after loading completes', async () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.queryByText('Loading animals…')).not.toBeInTheDocument();
      });

      expect(screen.getByText('TAG001')).toBeInTheDocument();
    });
  });

  describe.skip('Error Handling', () => {
    it('should display error message when loading fails', async () => {
      mockAnimalService.getAnimals.mockRejectedValueOnce(new Error('Failed to load animals'));

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText(/failed to load animals/i)).toBeInTheDocument();
      });
    });

    it('should show empty state when no animals exist', async () => {
      mockAnimalService.getAnimals.mockResolvedValueOnce({
        data: [],
        pagination: { current: 1, pages: 0, total: 0 },
      });

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('No animals found.')).toBeInTheDocument();
      });
    });
  });

  describe.skip('Refresh Animals', () => {
    it('should reload animals when refresh button is clicked', async () => {
      const user = userEvent.setup();

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      expect(mockAnimalService.getAnimals).toHaveBeenCalledTimes(1);

      const refreshButton = screen.getByRole('button', { name: /reload/i });
      await user.click(refreshButton);

      await waitFor(() => {
        expect(mockAnimalService.getAnimals).toHaveBeenCalledTimes(2);
      });
    });
  });

  describe.skip('Add Animal Dialog', () => {
    it.skip('should open dialog when add button is clicked', async () => {
      const user = userEvent.setup();

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const addButton = screen.getByRole('button', { name: /add animal/i });
      await user.click(addButton);

      expect(screen.getByRole('dialog')).toBeInTheDocument();
      expect(screen.getByText('Add Animal')).toBeInTheDocument();
    });

    it('should close dialog when cancel button is clicked', async () => {
      const user = userEvent.setup();

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const addButton = screen.getByRole('button', { name: /add animal/i });
      await user.click(addButton);

      const cancelButton = screen.getByRole('button', { name: /cancel/i });
      await user.click(cancelButton);

      await waitFor(() => {
        expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
      });
    });

    it('should have all form fields in the dialog', async () => {
      const user = userEvent.setup();

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const addButton = screen.getByRole('button', { name: /add animal/i });
      await user.click(addButton);

      expect(screen.getByLabelText(/tag number/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/^name$/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/species/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/gender/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/health status/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/acquisition type/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/acquisition date/i)).toBeInTheDocument();
    });

    it('should show error when tag number is missing', async () => {
      const user = userEvent.setup();

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const addButton = screen.getByRole('button', { name: /add animal/i });
      await user.click(addButton);

      const saveButton = screen.getByRole('button', { name: /^save$/i });
      await user.click(saveButton);

      await waitFor(() => {
        expect(screen.getByText(/tag number is required/i)).toBeInTheDocument();
      });

      expect(mockAnimalService.createAnimal).not.toHaveBeenCalled();
    });

    it.skip('should create animal with valid data', async () => {
      const user = userEvent.setup();
      const newAnimal: Animal = {
        id: 'animal4',
        farm: 'farm1',
        tagNumber: 'TAG004',
        name: 'Charlie',
        species: 'horse',
        gender: 'male',
        healthStatus: 'healthy',
        acquisitionInfo: {
          type: 'purchased',
          date: '2024-04-01',
        },
        healthRecords: [],
        productionRecords: [],
        feedingSchedule: [],
        createdAt: '2024-04-01T10:00:00Z',
        updatedAt: '2024-04-01T10:00:00Z',
        createdBy: 'user1',
      };

      mockAnimalService.createAnimal.mockResolvedValueOnce(newAnimal);

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const addButton = screen.getByRole('button', { name: /add animal/i });
      await user.click(addButton);

      // Fill in the form
      const tagInput = screen.getByLabelText(/tag number/i);
      await user.clear(tagInput);
      await user.type(tagInput, 'TAG004');

      const nameInput = screen.getByLabelText(/^name$/i);
      await user.clear(nameInput);
      await user.type(nameInput, 'Charlie');

      // Select species
      const speciesSelect = screen.getByLabelText(/species/i);
      await user.click(speciesSelect);
      const horseOption = await screen.findByRole('option', { name: /horse/i });
      await user.click(horseOption);

      // Select gender
      const genderSelect = screen.getByLabelText(/gender/i);
      await user.click(genderSelect);
      const maleOption = await screen.findByRole('option', { name: /male/i });
      await user.click(maleOption);

      const saveButton = screen.getByRole('button', { name: /^save$/i });
      await user.click(saveButton);

      await waitFor(() => {
        expect(mockAnimalService.createAnimal).toHaveBeenCalledWith(
          expect.objectContaining({
            farm: 'farm1',
            tagNumber: 'TAG004',
            name: 'Charlie',
            species: 'horse',
            gender: 'male',
            healthStatus: 'healthy',
          })
        );
      });

      // Success message
      expect(screen.getByText(/animal created/i)).toBeInTheDocument();

      // Dialog should close
      await waitFor(() => {
        expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
      });

      // New animal should appear in table
      expect(screen.getByText('TAG004')).toBeInTheDocument();
      expect(screen.getByText('Charlie')).toBeInTheDocument();
    });

    it('should handle create animal error', async () => {
      const user = userEvent.setup();
      mockAnimalService.createAnimal.mockRejectedValueOnce(new Error('Failed to create animal'));

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const addButton = screen.getByRole('button', { name: /add animal/i });
      await user.click(addButton);

      const tagInput = screen.getByLabelText(/tag number/i);
      await user.type(tagInput, 'TAG999');

      const saveButton = screen.getByRole('button', { name: /^save$/i });
      await user.click(saveButton);

      await waitFor(() => {
        expect(screen.getByText(/failed to create animal/i)).toBeInTheDocument();
      });

      // Dialog should still be open
      expect(screen.getByRole('dialog')).toBeInTheDocument();
    });
  });

  describe.skip('Delete Animal', () => {
    it('should show delete buttons for each animal', async () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });
      expect(deleteButtons).toHaveLength(3);
    });

    it('should cancel delete when confirmation is denied', async () => {
      const user = userEvent.setup();
      (window.confirm as jest.Mock).mockReturnValueOnce(false);

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });
      await user.click(deleteButtons[0]);

      expect(window.confirm).toHaveBeenCalledWith('Delete this animal? This cannot be undone.');
      expect(mockAnimalService.deleteAnimal).not.toHaveBeenCalled();
    });

    it('should delete animal when confirmed', async () => {
      const user = userEvent.setup();
      (window.confirm as jest.Mock).mockReturnValueOnce(true);
      mockAnimalService.deleteAnimal.mockResolvedValueOnce(undefined);

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });
      await user.click(deleteButtons[0]);

      await waitFor(() => {
        expect(mockAnimalService.deleteAnimal).toHaveBeenCalledWith('animal1');
      });

      // Success message
      expect(screen.getByText(/animal deleted/i)).toBeInTheDocument();

      // Animal should be removed from table
      await waitFor(() => {
        expect(screen.queryByText('TAG001')).not.toBeInTheDocument();
      });

      expect(screen.getByText('TAG002')).toBeInTheDocument();
      expect(screen.getByText('TAG003')).toBeInTheDocument();
    });

    it('should handle delete error', async () => {
      const user = userEvent.setup();
      (window.confirm as jest.Mock).mockReturnValueOnce(true);
      mockAnimalService.deleteAnimal.mockRejectedValueOnce(new Error('Failed to delete animal'));

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });
      await user.click(deleteButtons[0]);

      await waitFor(() => {
        expect(screen.getByText(/failed to delete animal/i)).toBeInTheDocument();
      });

      // Animal should still be in table
      expect(screen.getByText('TAG001')).toBeInTheDocument();
    });
  });

  describe.skip('Animal Display', () => {
    it('should display health status chips with correct colors', async () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const healthyChip = screen.getByText('healthy');
      expect(healthyChip).toBeInTheDocument();

      const sickChip = screen.getByText('sick');
      expect(sickChip).toBeInTheDocument();

      const quarantineChip = screen.getByText('quarantine');
      expect(quarantineChip).toBeInTheDocument();
    });

    it('should display species and gender capitalized', async () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      // Check that species are displayed (table cell should have textTransform: capitalize)
      const rows = screen.getAllByRole('row');
      expect(rows.length).toBeGreaterThan(1); // Header + data rows
    });

    it('should format creation dates correctly', async () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      // Dates should be formatted using toLocaleDateString
      const rows = screen.getAllByRole('row');
      expect(rows.length).toBe(4); // 1 header + 3 data rows
    });

    it('should show dash for missing animal names', async () => {
      const animalWithoutName: Animal = {
        ...mockAnimals[0],
        id: 'animal5',
        tagNumber: 'TAG005',
        name: undefined,
      };

      mockAnimalService.getAnimals.mockResolvedValueOnce({
        data: [animalWithoutName],
        pagination: { current: 1, pages: 1, total: 1 },
      });

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG005')).toBeInTheDocument();
      });

      const row = screen.getByText('TAG005').closest('tr');
      expect(within(row as HTMLElement).getByText('-')).toBeInTheDocument();
    });
  });

  describe.skip('Accessibility', () => {
    it('should have proper labels for form inputs', async () => {
      const user = userEvent.setup();

      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      const addButton = screen.getByRole('button', { name: /add animal/i });
      await user.click(addButton);

      // All inputs should have accessible labels
      expect(screen.getByLabelText(/tag number/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/^name$/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/species/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/gender/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/health status/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/acquisition type/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/acquisition date/i)).toBeInTheDocument();
    });

    it('should have tooltips for icon buttons', async () => {
      renderWithProviders(<AnimalsManagement />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('TAG001')).toBeInTheDocument();
      });

      expect(screen.getByRole('button', { name: /reload/i })).toBeInTheDocument();
      
      const deleteButtons = screen.getAllByRole('button', { name: /delete/i });
      expect(deleteButtons.length).toBeGreaterThan(0);
    });
  });
});
