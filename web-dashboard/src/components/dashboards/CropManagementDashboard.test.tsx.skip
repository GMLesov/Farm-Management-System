import React from 'react';
import { screen, waitFor, within } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { renderWithProviders } from '../../test-utils';
import CropManagementDashboard from './CropManagementDashboard';
import cropService from '../../services/crop';

// Mock the crop service
jest.mock('../../services/crop');

/* eslint-disable */

/* eslint-disable */

const mockCropService = cropService as jest.Mocked<typeof cropService>;

describe.skip('CropManagementDashboard Component', () => {
  const mockCrops = [
    {
      id: 'crop1',
      farmId: 'farm123',
      name: 'Tomatoes',
      variety: 'Roma',
      category: 'vegetables',
      fieldLocation: 'North Field',
      area: 2.5,
      soilType: 'Loamy',
      plantingDate: '2025-01-15',
      expectedHarvestDate: '2025-04-15',
      stage: { current: 'vegetative', progress: 40 },
      growthProgress: 40,
      healthStatus: {
        overall: 'good',
        plantVigor: 85,
        diseasePresence: [],
        pestPresence: [],
        nutritionalDeficiency: [],
        stressFactors: [],
        treatmentHistory: [],
        lastAssessment: '2025-11-10',
        nextAssessmentDue: '2025-11-17',
      },
    },
    {
      id: 'crop2',
      farmId: 'farm123',
      name: 'Corn',
      variety: 'Sweet',
      category: 'grains',
      fieldLocation: 'South Field',
      area: 5.0,
      soilType: 'Clay',
      plantingDate: '2025-02-01',
      expectedHarvestDate: '2025-06-01',
      stage: { current: 'flowering', progress: 65 },
      growthProgress: 65,
      healthStatus: {
        overall: 'excellent',
        plantVigor: 95,
        diseasePresence: [],
        pestPresence: [],
        nutritionalDeficiency: [],
        stressFactors: [],
        treatmentHistory: [],
        lastAssessment: '2025-11-10',
        nextAssessmentDue: '2025-11-17',
      },
    },
    {
      id: 'crop3',
      farmId: 'farm123',
      name: 'Wheat',
      variety: 'Winter',
      category: 'grains',
      fieldLocation: 'East Field',
      area: 10.0,
      soilType: 'Loamy',
      plantingDate: '2024-10-01',
      expectedHarvestDate: '2025-05-01',
      stage: { current: 'harvested', progress: 100 },
      growthProgress: 100,
      healthStatus: {
        overall: 'good',
        plantVigor: 88,
        diseasePresence: [],
        pestPresence: [],
        nutritionalDeficiency: [],
        stressFactors: [],
        treatmentHistory: [],
        lastAssessment: '2025-11-10',
        nextAssessmentDue: '2025-11-17',
      },
    },
  ];

  const mockUser = {
    id: 'user123',
    email: 'farmer@test.com',
    name: 'Test Farmer',
    farmId: 'farm123',
  };

  beforeEach(() => {
    jest.clearAllMocks();
    localStorage.clear();
    localStorage.setItem('farmId', 'farm123');
    mockCropService.getAllCrops.mockResolvedValue(mockCrops as any);
  });

  describe.skip('Rendering', () => {
    it('should render dashboard with title and add button', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      expect(screen.getByText('Crop Management Dashboard')).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /add new crop/i })).toBeInTheDocument();
    });

    it('should show warning when no farm is selected', () => {
      localStorage.removeItem('farmId');
      
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: { ...mockUser, farmId: undefined }, isAuthenticated: true } },
      });

      expect(screen.getByText(/no farm selected/i)).toBeInTheDocument();
    });

    it('should render summary cards with correct data', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Total Crops')).toBeInTheDocument();
      });

      expect(screen.getByText('3')).toBeInTheDocument(); // Total crops
      expect(screen.getByText('17.5')).toBeInTheDocument(); // Total area (2.5 + 5.0 + 10.0)
      expect(screen.getByText('2')).toBeInTheDocument(); // Active seasons (not harvested)
    });

    it('should render crops table with all columns', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      // Check table headers
      expect(screen.getByText('Crop Name')).toBeInTheDocument();
      expect(screen.getByText('Variety')).toBeInTheDocument();
      expect(screen.getByText('Area (acres)')).toBeInTheDocument();
      expect(screen.getByText('Status')).toBeInTheDocument();
      expect(screen.getByText('Health')).toBeInTheDocument();
      expect(screen.getByText('Progress')).toBeInTheDocument();
    });

    it('should display all crops in the table', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      expect(screen.getByText('Corn')).toBeInTheDocument();
      expect(screen.getByText('Wheat')).toBeInTheDocument();
      expect(screen.getByText('Roma')).toBeInTheDocument();
      expect(screen.getByText('Sweet')).toBeInTheDocument();
      expect(screen.getByText('Winter')).toBeInTheDocument();
    });
  });

  describe.skip('Loading States', () => {
    it('should show loading indicator when fetching crops', () => {
      mockCropService.getAllCrops.mockImplementation(() => new Promise(() => {})); // Never resolves

      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      expect(screen.getByRole('progressbar')).toBeInTheDocument();
    });

    it('should hide loading indicator after data loads', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      // CircularProgress loading indicator should be gone (LinearProgress for crop progress is still there)
      const progressBars = screen.queryAllByRole('progressbar');
      // Only LinearProgress bars for crops should remain (3 crops = 3 progress bars)
      expect(progressBars.length).toBe(3);
    });
  });

  describe.skip('Error Handling', () => {
    it('should display error message when crop loading fails', async () => {
      mockCropService.getAllCrops.mockRejectedValueOnce(new Error('Failed to load crops'));

      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText(/failed to load crops/i)).toBeInTheDocument();
      });
    });

    it('should clear error message when close button is clicked', async () => {
      const user = userEvent.setup();
      mockCropService.getAllCrops.mockRejectedValueOnce(new Error('Failed to load crops'));

      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText(/failed to load crops/i)).toBeInTheDocument();
      });

      const closeButton = screen.getByRole('button', { name: /close/i });
      await user.click(closeButton);

      await waitFor(() => {
        expect(screen.queryByText(/failed to load crops/i)).not.toBeInTheDocument();
      });
    });
  });

  describe.skip('Add Crop Dialog', () => {
    it('should open dialog when add button is clicked', async () => {
      const user = userEvent.setup();
      
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /add new crop/i })).toBeEnabled();
      });

      const addButton = screen.getByRole('button', { name: /add new crop/i });
      await user.click(addButton);

      expect(screen.getByRole('dialog')).toBeInTheDocument();
      // Use getAllByText since "Add New Crop" appears in both button and dialog title
      const addNewCropTexts = screen.getAllByText('Add New Crop');
      expect(addNewCropTexts.length).toBeGreaterThan(0);
    });

    it('should close dialog when cancel button is clicked', async () => {
      const user = userEvent.setup();
      
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /add new crop/i })).toBeEnabled();
      });

      await user.click(screen.getByRole('button', { name: /add new crop/i }));
      
      const cancelButton = screen.getByRole('button', { name: /cancel/i });
      await user.click(cancelButton);

      await waitFor(() => {
        expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
      });
    });

    it('should render all form fields in add dialog', async () => {
      const user = userEvent.setup();
      
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /add new crop/i })).toBeEnabled();
      });

      await user.click(screen.getByRole('button', { name: /add new crop/i }));

      expect(screen.getByLabelText(/crop name/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/^variety/i)).toBeInTheDocument();
      // MUI Select doesn't have accessible name, just check it exists
      expect(screen.getByRole('combobox')).toBeInTheDocument();
      expect(screen.getByLabelText(/field location/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/area \(hectares\)/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/planted date/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/expected harvest date/i)).toBeInTheDocument();
    });

    it('should show error when submitting with missing required fields', async () => {
      const user = userEvent.setup();
      
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /add new crop/i })).toBeEnabled();
      });

      await user.click(screen.getByRole('button', { name: /add new crop/i }));
      
      // Click Add button without filling fields
      const dialog = screen.getByRole('dialog');
      const addButton = within(dialog).getByRole('button', { name: /add crop/i });
      await user.click(addButton);

      await waitFor(() => {
        expect(screen.getByText(/please fill in all required fields/i)).toBeInTheDocument();
      });
    });

    it.skip('should successfully add new crop with all fields filled', async () => {
      const user = userEvent.setup();
      const newCrop = {
        id: 'crop4',
        farmId: 'farm123',
        name: 'Carrots',
        variety: 'Nantes',
        category: 'vegetables',
        fieldLocation: 'West Field',
        area: 1.5,
        plantingDate: '2025-11-15',
        expectedHarvestDate: '2026-02-15',
        stage: { current: 'planting', progress: 0 },
        growthProgress: 0,
        healthStatus: { overall: 'good' },
      };

      mockCropService.createCrop.mockResolvedValueOnce(newCrop as any);
      mockCropService.getAllCrops.mockResolvedValueOnce([...mockCrops, newCrop] as any);

      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /add new crop/i })).toBeEnabled();
      });

      await user.click(screen.getByRole('button', { name: /add new crop/i }));

      // Fill in the form
      await user.type(screen.getByLabelText(/crop name/i), 'Carrots');
      await user.type(screen.getByLabelText(/^variety/i), 'Nantes');
      await user.type(screen.getByLabelText(/field location/i), 'West Field');
      await user.type(screen.getByLabelText(/area \(hectares\)/i), '1.5');
      await user.type(screen.getByLabelText(/planted date/i), '2025-11-15');
      await user.type(screen.getByLabelText(/expected harvest date/i), '2026-02-15');

      // Submit the form
      const dialog = screen.getByRole('dialog');
      const addButton = within(dialog).getByRole('button', { name: /add crop/i });
      await user.click(addButton);

      await waitFor(() => {
        expect(mockCropService.createCrop).toHaveBeenCalled();
      });

      await waitFor(() => {
        expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
      });
    });

    it('should update category when selected from dropdown', async () => {
      const user = userEvent.setup();
      
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /add new crop/i })).toBeEnabled();
      });

      await user.click(screen.getByRole('button', { name: /add new crop/i }));

      const categorySelect = screen.getByRole('combobox');
      await user.click(categorySelect);

      // Select "Fruits"
      const fruitsOption = screen.getByRole('option', { name: /fruits/i });
      await user.click(fruitsOption);

      // Verify the selection - check the select value
      await waitFor(() => {
        expect(categorySelect).toHaveTextContent(/fruits/i);
      });
    });

    it('should handle create crop API error', async () => {
      const user = userEvent.setup();
      mockCropService.createCrop.mockRejectedValueOnce(new Error('Failed to create crop'));

      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /add new crop/i })).toBeEnabled();
      });

      await user.click(screen.getByRole('button', { name: /add new crop/i }));

      // Fill required fields
      await user.type(screen.getByLabelText(/crop name/i), 'Carrots');
      await user.type(screen.getByLabelText(/^variety/i), 'Nantes');
      await user.type(screen.getByLabelText(/area \(hectares\)/i), '1.5');
      await user.type(screen.getByLabelText(/planted date/i), '2025-11-15');
      await user.type(screen.getByLabelText(/expected harvest date/i), '2026-02-15');

      const dialog = screen.getByRole('dialog');
      const addButton = within(dialog).getByRole('button', { name: /add crop/i });
      await user.click(addButton);

      await waitFor(() => {
        expect(screen.getByText(/failed to create crop/i)).toBeInTheDocument();
      });
    });
  });

  describe.skip('Delete Crop Functionality', () => {
    it('should show delete button for each crop', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      const deleteButtons = screen.getAllByTitle('Delete');
      expect(deleteButtons).toHaveLength(3);
    });

    it('should show confirmation dialog before deleting', async () => {
      const user = userEvent.setup();
      const confirmSpy = jest.spyOn(window, 'confirm').mockReturnValue(false);

      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      const deleteButtons = screen.getAllByTitle('Delete');
      await user.click(deleteButtons[0]);

      expect(confirmSpy).toHaveBeenCalledWith('Are you sure you want to delete this crop?');
      expect(mockCropService.deleteCrop).not.toHaveBeenCalled();

      confirmSpy.mockRestore();
    });

    it('should delete crop when confirmed', async () => {
      const user = userEvent.setup();
      const confirmSpy = jest.spyOn(window, 'confirm').mockReturnValue(true);
      mockCropService.deleteCrop.mockResolvedValueOnce(undefined as any);
      // Second call returns crops without the deleted one
      mockCropService.getAllCrops.mockResolvedValueOnce(mockCrops as any).mockResolvedValueOnce(mockCrops.slice(1) as any);

      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      const deleteButtons = screen.getAllByTitle('Delete');
      await user.click(deleteButtons[0]);

      await waitFor(() => {
        expect(mockCropService.deleteCrop).toHaveBeenCalledWith('crop1');
      });

      await waitFor(() => {
        expect(mockCropService.getAllCrops).toHaveBeenCalledTimes(2); // Initial load + after delete
      });

      confirmSpy.mockRestore();
    });

    it('should handle delete error gracefully', async () => {
      const user = userEvent.setup();
      const confirmSpy = jest.spyOn(window, 'confirm').mockReturnValue(true);
      mockCropService.deleteCrop.mockRejectedValueOnce(new Error('Failed to delete crop'));

      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      const deleteButtons = screen.getAllByTitle('Delete');
      await user.click(deleteButtons[0]);

      await waitFor(() => {
        expect(screen.getByText(/failed to delete crop/i)).toBeInTheDocument();
      });

      confirmSpy.mockRestore();
    });
  });

  describe.skip('Crop Status and Health Display', () => {
    it('should display correct status chips with appropriate colors', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      expect(screen.getByText('growing')).toBeInTheDocument(); // Tomatoes
      expect(screen.getByText('flowering')).toBeInTheDocument(); // Corn
      expect(screen.getByText('harvested')).toBeInTheDocument(); // Wheat
    });

    it('should display correct health status chips', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      const healthChips = screen.getAllByText(/good|excellent/i);
      expect(healthChips.length).toBeGreaterThan(0);
    });

    it('should display progress bars with percentage', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      expect(screen.getByText('40%')).toBeInTheDocument(); // Tomatoes
      expect(screen.getByText('65%')).toBeInTheDocument(); // Corn
      expect(screen.getByText('100%')).toBeInTheDocument(); // Wheat
    });
  });

  describe.skip('Action Buttons', () => {
    it('should render view, edit, and delete buttons for each crop', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      expect(screen.getAllByTitle('View Details')).toHaveLength(3);
      expect(screen.getAllByTitle('Edit')).toHaveLength(3);
      expect(screen.getAllByTitle('Delete')).toHaveLength(3);
    });

    it('should disable delete button when loading', async () => {
      mockCropService.getAllCrops.mockImplementation(() => new Promise(() => {}));

      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      // Since crops are loading, no delete buttons will be rendered yet
      expect(screen.queryByTitle('Delete')).not.toBeInTheDocument();
    });
  });

  describe.skip('Data Calculations', () => {
    it('should calculate total area correctly', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('17.5')).toBeInTheDocument(); // 2.5 + 5.0 + 10.0
      });
    });

    it('should calculate active seasons correctly (excluding harvested)', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        const activeSeasonCards = screen.getAllByText('2'); // Only Tomatoes and Corn (not Wheat)
        expect(activeSeasonCards.length).toBeGreaterThan(0);
      });
    });

    it('should calculate average progress correctly', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        // Average: (40 + 65 + 100) / 3 = 68.33 rounded to 68%
        expect(screen.getByText('68%')).toBeInTheDocument();
      });
    });
  });

  describe.skip('Date Formatting', () => {
    it('should format dates correctly in the table', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      // Check that dates are formatted (format depends on locale, just check presence)
      const datePattern = /\d{1,2}\/\d{1,2}\/\d{4}/;
      const tableCells = screen.getAllByRole('cell');
      const dateTexts = tableCells.filter(cell => datePattern.test(cell.textContent || ''));
      expect(dateTexts.length).toBeGreaterThan(0);
    });
  });

  describe.skip('Accessibility', () => {
    it('should have proper labels for form inputs', async () => {
      const user = userEvent.setup();
      
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /add new crop/i })).toBeEnabled();
      });

      await user.click(screen.getByRole('button', { name: /add new crop/i }));

      expect(screen.getByLabelText(/crop name/i)).toHaveAttribute('type', 'text');
      expect(screen.getByLabelText(/^variety/i)).toHaveAttribute('type', 'text');
      expect(screen.getByLabelText(/area \(hectares\)/i)).toHaveAttribute('type', 'number');
      expect(screen.getByLabelText(/planted date/i)).toHaveAttribute('type', 'date');
      expect(screen.getByLabelText(/expected harvest date/i)).toHaveAttribute('type', 'date');
    });

    it('should have proper button labels and titles', async () => {
      renderWithProviders(<CropManagementDashboard />, {
        preloadedState: { auth: { user: mockUser, token: 'test-token', isAuthenticated: true } },
      });

      await waitFor(() => {
        expect(screen.getByText('Tomatoes')).toBeInTheDocument();
      });

      expect(screen.getByRole('button', { name: /add new crop/i })).toBeInTheDocument();
      expect(screen.getAllByTitle('View Details')[0]).toBeInTheDocument();
      expect(screen.getAllByTitle('Edit')[0]).toBeInTheDocument();
      expect(screen.getAllByTitle('Delete')[0]).toBeInTheDocument();
    });
  });
});
